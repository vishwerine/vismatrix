{% extends 'tracker/base.html' %}

{% block title %}{{ plan.title }} - Shared Plan{% endblock %}

{% block content %}

<div class="container mx-auto px-4 py-6 max-w-7xl">
  <!-- Shared Plan Banner -->
  <div class="alert alert-info mb-6 shadow-lg">
    <i class="bi bi-share"></i>
    <div>
      <h3 class="font-bold">Shared Plan</h3>
      <div class="text-sm">
        This plan was shared by <strong>{{ owner.username }}</strong>. 
        <span class="opacity-70">This is a read-only view.</span>
      </div>
    </div>
  </div>

  <!-- Header -->
  <div class="flex justify-between items-start mb-6">
    <div>
      <div class="flex items-center gap-3 mb-2">
        <h1 class="text-3xl font-bold text-slate-800">
          {{ plan.title }}
          {% if not plan.is_active %}
            <span class="badge badge-ghost ml-2">Inactive</span>
          {% endif %}
        </h1>
      </div>
      {% if plan.description %}
        <p class="text-slate-600">{{ plan.description }}</p>
      {% endif %}
    </div>
  </div>

  <!-- Stats -->
  <div class="stats shadow mb-6 w-full">
    <div class="stat">
      <div class="stat-figure text-primary">
        <i class="bi bi-diagram-3 text-3xl"></i>
      </div>
      <div class="stat-title">Total Tasks</div>
      <div class="stat-value text-primary">{{ total_nodes }}</div>
      <div class="stat-desc">Tasks in this plan</div>
    </div>
    <div class="stat">
      <div class="stat-figure text-success">
        <i class="bi bi-check-circle text-3xl"></i>
      </div>
      <div class="stat-title">Completed</div>
      <div class="stat-value text-success">{{ completed_nodes }}</div>
      <div class="stat-desc">{% if total_nodes > 0 %}{{ completed_nodes }}/{{ total_nodes }} ({% widthratio completed_nodes total_nodes 100 %}%){% endif %}</div>
    </div>
    <div class="stat">
      <div class="stat-figure text-warning">
        <i class="bi bi-hourglass-split text-3xl"></i>
      </div>
      <div class="stat-title">In Progress</div>
      <div class="stat-value text-warning">{{ in_progress_nodes }}</div>
      <div class="stat-desc">Currently working</div>
    </div>
    <div class="stat">
      <div class="stat-figure text-info">
        <i class="bi bi-clock text-3xl"></i>
      </div>
      <div class="stat-title">Pending</div>
      <div class="stat-value text-info">{{ pending_nodes }}</div>
      <div class="stat-desc">Not started</div>
    </div>
  </div>
  
  {% if nodes %}
    <!-- DAG Visualization (Read-Only) -->
    <div class="card bg-base-100 shadow-xl mb-6">
      <div class="card-body">
        <div class="flex justify-between items-center mb-4 flex-wrap gap-3">
          <h2 class="card-title">
            <i class="bi bi-diagram-3 mr-2"></i>Task Flow
          </h2>
        </div>

        <!-- Legend -->
        <div class="flex flex-wrap gap-3 mb-4 text-sm">
          <div class="flex items-center gap-2">
            <div class="w-4 h-4 rounded bg-success/20 border-2 border-success"></div>
            <span>Completed</span>
          </div>
          <div class="flex items-center gap-2">
            <div class="w-4 h-4 rounded bg-warning/20 border-2 border-warning"></div>
            <span>In Progress</span>
          </div>
          <div class="flex items-center gap-2">
            <div class="w-4 h-4 rounded bg-info/20 border-2 border-info"></div>
            <span>Ready to Start</span>
          </div>
          <div class="flex items-center gap-2">
            <div class="w-4 h-4 rounded bg-base-100 border-2 border-base-300"></div>
            <span>Waiting</span>
          </div>
        </div>

        <div id="dag-container"
             class="border-2 border-base-300 rounded-lg bg-gradient-to-br from-base-200 to-base-300 relative"
             style="height: 600px; min-width: 100%;">

          <canvas id="dag-canvas" class="absolute inset-0 w-full h-full" style="touch-action: none;"></canvas>

          <!-- View controls -->
          <div class="absolute top-3 right-3 z-40 flex flex-col gap-2">
            <button class="btn btn-sm btn-circle btn-outline shadow-lg" onclick="fitView()" title="Fit to screen">
              <i class="bi bi-arrows-fullscreen"></i>
            </button>
            <button class="btn btn-sm btn-circle btn-outline shadow-lg" onclick="zoomIn()" title="Zoom in">
              <i class="bi bi-zoom-in"></i>
            </button>
            <button class="btn btn-sm btn-circle btn-outline shadow-lg" onclick="zoomOut()" title="Zoom out">
              <i class="bi bi-zoom-out"></i>
            </button>
          </div>

          <!-- Status Bar -->
          <div class="absolute bottom-2 left-2 right-2 bg-base-100/90 backdrop-blur-sm border border-base-300 rounded-lg px-3 py-2 text-xs text-base-content/70 z-30">
            <div class="flex justify-between items-center flex-wrap gap-2">
              <div>Read-only view • Drag to pan • Wheel/pinch to zoom • Tap tasks for details</div>
            </div>
          </div>

        </div>
      </div>
    </div>

    <!-- Task List (Read-Only) -->
    <div class="card bg-base-100 shadow-xl">
      <div class="card-body">
        <h2 class="card-title mb-4">
          <i class="bi bi-list-ul mr-2"></i>Task List
        </h2>
        <div class="space-y-3">
          {% for node in nodes %}
            <div class="flex items-center gap-4 p-4 bg-base-200 rounded-lg">
              <div class="flex-1">
                <div class="flex items-center gap-2 mb-1 flex-wrap">
                  <h3 class="font-semibold">{{ node.task.title }}</h3>
                  {% if node.task.status == 'completed' %}
                    <span class="badge badge-success badge-sm">✓ Completed</span>
                  {% elif node.task.status == 'in_progress' %}
                    <span class="badge badge-warning badge-sm">In Progress</span>
                  {% else %}
                    <span class="badge badge-ghost badge-sm">Not Started</span>
                  {% endif %}

                  {% if node.task.priority == 'high' %}
                    <span class="badge badge-error badge-sm">High Priority</span>
                  {% elif node.task.priority == 'medium' %}
                    <span class="badge badge-warning badge-sm">Medium</span>
                  {% endif %}
                </div>

                {% if node.task.description %}
                  <p class="text-sm text-base-content/70 mb-2">{{ node.task.description|truncatewords:20 }}</p>
                {% endif %}

                {% if node.dependencies.exists %}
                  <div class="text-sm text-base-content/60">
                    <i class="bi bi-arrow-return-right mr-1"></i>
                    Depends on:
                    {% for dep in node.dependencies.all %}
                      <span class="badge badge-outline badge-xs">{{ dep.task.title }}</span>{% if not forloop.last %}, {% endif %}
                    {% endfor %}
                  </div>
                {% endif %}
              </div>
            </div>
          {% endfor %}
        </div>
      </div>
    </div>

  {% else %}
    <div class="card bg-base-100 shadow-xl">
      <div class="card-body flex flex-col items-center justify-center py-16">
        <div class="text-6xl mb-4 opacity-20">
          <i class="bi bi-diagram-3"></i>
        </div>
        <h3 class="text-xl font-semibold text-slate-700 mb-2">No tasks in this plan yet</h3>
      </div>
    </div>
  {% endif %}

</div>

{% if nodes %}
<script>
// Read-only visualization (simplified version without editing)
(() => {
  const canvas = document.getElementById('dag-canvas');
  const ctx = canvas.getContext('2d');
  let W = 0, H = 0, DPR = 1;

  function resize() {
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    W = Math.max(1, Math.floor(rect.width));
    H = Math.max(1, Math.floor(rect.height));
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    requestRender();
  }
  window.addEventListener('resize', resize, { passive: true });

  let nodes = {{ nodes_data|safe }}.map(n => ({
    ...n,
    x: (n.position_x ?? 0),
    y: (n.position_y ?? 0),
    r: 45,
  }));

  let view = { x: 0, y: 0, s: 1.0 };
  const pointer = { down: false, sx: 0, sy: 0, lastSx: 0, lastSy: 0, panning: false };

  function worldToScreen(wx, wy) { return { x: wx * view.s + view.x, y: wy * view.s + view.y }; }
  function screenToWorld(sx, sy) { return { x: (sx - view.x) / view.s, y: (sy - view.y) / view.s }; }

  function getNodeColor(node) {
    if (node.task_status === 'completed') return { bg: '#dcfce7', border: '#22c55e', text: '#166534' };
    if (node.task_status === 'in_progress') return { bg: '#fef3c7', border: '#f59e0b', text: '#92400e' };
    if (node.can_start) return { bg: '#dbeafe', border: '#3b82f6', text: '#1e3a8a' };
    return { bg: '#f3f4f6', border: '#9ca3af', text: '#4b5563' };
  }

  function drawArrow(fromNode, toNode) {
    const ax = fromNode.x, ay = fromNode.y;
    const bx = toNode.x, by = toNode.y;
    const dx = bx - ax, dy = by - ay;
    const len = Math.hypot(dx, dy) || 1;
    const ux = dx / len, uy = dy / len;
    const sx = ax + ux * fromNode.r, sy = ay + uy * fromNode.r;
    const ex = bx - ux * toNode.r, ey = by - uy * toNode.r;

    ctx.strokeStyle = 'rgba(148, 163, 184, 0.65)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(ex, ey);
    ctx.stroke();

    const head = 12 / view.s;
    const angle = Math.atan2(ey - sy, ex - sx);
    ctx.fillStyle = 'rgba(148, 163, 184, 0.75)';
    ctx.beginPath();
    ctx.moveTo(ex, ey);
    ctx.lineTo(ex - head * Math.cos(angle - Math.PI/7), ey - head * Math.sin(angle - Math.PI/7));
    ctx.lineTo(ex - head * Math.cos(angle + Math.PI/7), ey - head * Math.sin(angle + Math.PI/7));
    ctx.closePath();
    ctx.fill();
  }

  let needsRender = true;
  function requestRender(){ needsRender = true; }

  function render() {
    if (!needsRender) return;
    needsRender = false;

    ctx.clearRect(0, 0, W, H);

    // Grid
    const grid = 60 * view.s;
    ctx.save();
    ctx.globalAlpha = 0.15;
    ctx.strokeStyle = 'rgba(148, 163, 184, 0.35)';
    ctx.lineWidth = 1;
    const startX = ((view.x % grid) + grid) % grid;
    const startY = ((view.y % grid) + grid) % grid;
    for (let x = startX; x < W; x += grid) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke(); }
    for (let y = startY; y < H; y += grid) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke(); }
    ctx.restore();

    ctx.save();
    ctx.translate(view.x, view.y);
    ctx.scale(view.s, view.s);

    // Draw edges
    const nodesById = new Map(nodes.map(n => [n.id, n]));
    for (const node of nodes) {
      if (node.dependencies && node.dependencies.length) {
        for (const depId of node.dependencies) {
          const depNode = nodesById.get(depId);
          if (depNode) drawArrow(depNode, node);
        }
      }
    }

    // Draw nodes
    for (const node of nodes) {
      const colors = getNodeColor(node);
      ctx.fillStyle = colors.bg;
      ctx.strokeStyle = colors.border;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(node.x, node.y, node.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = colors.text;
      ctx.font = `${18 / view.s}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const icon = node.task_status === 'completed' ? '✓' : node.task_status === 'in_progress' ? '⏳' : '○';
      ctx.fillText(icon, node.x, node.y - 10);

      ctx.font = `bold ${13 / view.s}px Arial`;
      const title = (node.task_title || '').length > 16 ? (node.task_title || '').slice(0, 16) + '…' : (node.task_title || '');
      ctx.fillText(title, node.x, node.y + 8);

      if (node.task_priority === 'high') {
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(node.x + node.r - 20, node.y - node.r + 5, 16, 10);
        ctx.fillStyle = 'white';
        ctx.font = `bold ${8 / view.s}px Arial`;
        ctx.fillText('!', node.x + node.r - 12, node.y - node.r + 10);
      }
    }

    ctx.restore();
  }

  let animationFrameId = null;
  function loop(){ 
    render(); 
    animationFrameId = requestAnimationFrame(loop); 
  }
  
  // Clean up animation loop when leaving the page
  window.addEventListener('beforeunload', function() {
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
    }
  });

  // Pan controls
  canvas.addEventListener('pointerdown', (e) => {
    const rect = canvas.getBoundingClientRect();
    pointer.down = true;
    pointer.panning = true;
    pointer.sx = pointer.lastSx = e.clientX - rect.left;
    pointer.sy = pointer.lastSy = e.clientY - rect.top;
  });

  canvas.addEventListener('pointermove', (e) => {
    if (!pointer.down || !pointer.panning) return;
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;
    view.x += sx - pointer.lastSx;
    view.y += sy - pointer.lastSy;
    pointer.lastSx = sx;
    pointer.lastSy = sy;
    requestRender();
  });

  canvas.addEventListener('pointerup', () => {
    pointer.down = false;
    pointer.panning = false;
  });

  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;
    const zoom = Math.exp(-e.deltaY * 0.001);
    const newS = Math.max(0.25, Math.min(3.0, view.s * zoom));
    const before = screenToWorld(sx, sy);
    view.s = newS;
    const after = screenToWorld(sx, sy);
    view.x += (after.x - before.x) * view.s;
    view.y += (after.y - before.y) * view.s;
    requestRender();
  }, { passive: false });

  window.zoomIn = () => { view.s = Math.min(3.0, view.s * 1.15); requestRender(); };
  window.zoomOut = () => { view.s = Math.max(0.25, view.s / 1.15); requestRender(); };
  
  window.fitView = () => {
    if (nodes.length === 0) { view.x = W/2; view.y = H/2; view.s = 1; requestRender(); return; }
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for (const n of nodes) {
      minX = Math.min(minX, n.x - n.r); minY = Math.min(minY, n.y - n.r);
      maxX = Math.max(maxX, n.x + n.r); maxY = Math.max(maxY, n.y + n.r);
    }
    const pad = 90, bw = (maxX - minX) + pad * 2, bh = (maxY - minY) + pad * 2;
    view.s = Math.max(0.25, Math.min(2.5, Math.min(W / bw, H / bh)));
    const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;
    view.x = W/2 - cx * view.s;
    view.y = H/2 - cy * view.s;
    requestRender();
  };

  resize();
  view.x = W / 2; view.y = H / 2; view.s = 1.0;
  
  if (nodes.length && nodes.every(n => (n.x === 0 && n.y === 0))) {
    nodes.forEach((n, i) => {
      const angle = (i / nodes.length) * Math.PI * 2;
      n.x = Math.cos(angle) * 170;
      n.y = Math.sin(angle) * 170;
    });
  }
  if (nodes.length) fitView();
  loop();
})();
</script>
{% endif %}

{% endblock %}
